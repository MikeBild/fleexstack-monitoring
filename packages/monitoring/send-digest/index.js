import pg from 'pg'

process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'

const pool = new pg.Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: true,
})

export async function main(event, context) {
  console.log('[send-digest] Started')

  const client = await pool.connect()
  try {
    const since = new Date(Date.now() - 24 * 60 * 60 * 1000)

    const { rows: [logStats] } = await client.query(
      `SELECT
         COUNT(*) as total,
         COUNT(*) FILTER (WHERE level IN ('error', 'fatal')) as errors,
         COUNT(*) FILTER (WHERE level = 'warn') as warnings
       FROM "LogEntry"
       WHERE timestamp > $1`,
      [since]
    )

    const { rows: [issueStats] } = await client.query(
      `SELECT
         COUNT(*) FILTER (WHERE status = 'open') as open,
         COUNT(*) FILTER (WHERE status = 'resolved' AND "resolvedAt" > $1) as resolved
       FROM "LogIssue"`,
      [since]
    )

    const { rows: topErrors } = await client.query(
      `SELECT message, COUNT(*) as count, source
       FROM "LogEntry"
       WHERE level IN ('error', 'fatal') AND timestamp > $1
       GROUP BY message, source
       ORDER BY count DESC
       LIMIT 5`,
      [since]
    )

    const { rows: criticalIssues } = await client.query(
      `SELECT type, severity, title, "detectedAt"
       FROM "LogIssue"
       WHERE status = 'open' AND severity IN ('high', 'critical')
       ORDER BY "detectedAt" DESC
       LIMIT 5`
    )

    const total = parseInt(logStats.total)
    const errors = parseInt(logStats.errors)
    const errorRate = total > 0 ? ((errors / total) * 100).toFixed(2) : '0.00'

    const digest = {
      date: new Date().toISOString().split('T')[0],
      summary: {
        totalLogs: total,
        errorLogs: errors,
        warningLogs: parseInt(logStats.warnings),
        errorRate: errorRate + '%',
        openIssues: parseInt(issueStats.open),
        resolvedIssues: parseInt(issueStats.resolved),
      },
      topErrors: topErrors.map(e => ({
        message: e.message.substring(0, 100),
        count: parseInt(e.count),
        source: e.source,
      })),
      criticalIssues: criticalIssues.map(i => ({
        type: i.type,
        severity: i.severity,
        title: i.title,
        detectedAt: i.detectedAt,
      })),
    }

    console.log('[send-digest] Digest:', JSON.stringify(digest))

    let issueUrl = null
    if (process.env.ALERTS_REPO && process.env.GH_TOKEN) {
      try {
        const issueBody = formatDigestAsMarkdown(digest)
        console.log(`[send-digest] Creating GitHub issue in ${process.env.ALERTS_REPO}`)

        const response = await fetch(`https://api.github.com/repos/${process.env.ALERTS_REPO}/issues`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${process.env.GH_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
            'User-Agent': 'Fleexstack-Monitoring-Bot',
          },
          body: JSON.stringify({
            title: `[Monitoring Digest] ${digest.date}`,
            body: issueBody,
            labels: ['monitoring', 'digest'],
          }),
        })

        if (response.ok) {
          const issue = await response.json()
          issueUrl = issue.html_url
          console.log(`[send-digest] Created GitHub issue: ${issueUrl}`)
        } else {
          const errorText = await response.text()
          console.error(`[send-digest] GitHub API error: ${response.status}`, errorText)
        }
      } catch (error) {
        console.error('[send-digest] Failed to create GitHub issue:', error.message)
      }
    } else {
      console.log('[send-digest] Skipping GitHub issue (ALERTS_REPO or GH_TOKEN not configured)')
    }

    console.log('[send-digest] Completed')

    return {
      body: {
        success: true,
        digest,
        issueUrl,
      },
    }
  } catch (error) {
    console.error('[send-digest] Fatal error:', error.message)
    return {
      body: {
        success: false,
        error: error.message,
      },
    }
  } finally {
    client.release()
  }
}

function formatDigestAsMarkdown(digest) {
  return `## Daily Monitoring Digest - ${digest.date}

### Summary
- **Total Logs**: ${digest.summary.totalLogs}
- **Errors**: ${digest.summary.errorLogs} (${digest.summary.errorRate})
- **Warnings**: ${digest.summary.warningLogs}
- **Open Issues**: ${digest.summary.openIssues}
- **Resolved Today**: ${digest.summary.resolvedIssues}

### Top Errors
${digest.topErrors.length > 0
  ? digest.topErrors.map(e => `- \`${e.source}\`: ${e.message} (${e.count}x)`).join('\n')
  : '_No errors in the last 24 hours_'}

### Critical Issues
${digest.criticalIssues.length > 0
  ? digest.criticalIssues.map(i => `- **[${i.severity.toUpperCase()}]** ${i.title}`).join('\n')
  : '_No critical issues_'}

---
_Generated by FleexStack Monitoring_`
}
